#!/bin/bash --
# barkeep - create entries based on a template for use with taverner
# requires imagemagick curl awk(\0)

usage() {
    cat <<'!'
usage: barkeep [-h] [-e editor] mk [-h] [-c cover] [-t template] [-n title] entry
       barkeep [-h] [-e editor] ed [-ht] [-c cover] [-n title] entry
       barkeep [-h] [-e editor] ls [-ht0]
       barkeep [-h] [-e editor] rm [-h] entry...

options
    -e editor  specify editor to use instead of EDITOR (default: vi)

examples
    create an entry called wipeout3 with a psx template using emacs as the
    editor:

        barkeep -e emacs mk -t psx -c ~/wipeout-3.jpg -n 'Wipeout 3 (PSX 1999)' wipeout3

    removes both wipeout3 and crash-bandicoot launchers along with their
    metadata:

        barkeep rm wipeout3 crash-bandicoot

!
}

mk_usage() {
    cat <<'!'
usage: mk [-h] [-c cover] [-t template] [-n title] entry

description
    create a new menu entry

options
    -h           this help menu
    -t template  select a template to base the new entry on
    -c cover     path or url to a cover image
    -n title     media title to display
    entry        the name for the new launcher script

!
}

ls_usage() {
    cat <<!
usage: ls [-ht0]

description
    list entries and templates

options
    -h  this help menu
    -t  list templates instead of entries
    -0  use NUL instead of a <newline> between items

!
}

ed_usage() {
    cat <<'!'
usage: ed [-c cover] [-n title] entry
       ed [-t] [-n title] entry
       ed [-n title] entry

description
    edit the selected entry

options
    -c cover  path or url to cover for the entry
    -n title  specify the title for the entry title
    -t        assumes entry refers to a template
    entry     attempts to open the entry with EDITOR (default: vi)

!
}

rm_usage() {
    cat <<!
usage: rm [-h] entry...

description
    remove selected entries and corresponding covers

options
    -h      this help menu
    entry   the chosen entry to remove

!
}

warn() {
    printf "%s: warning: $1" barkeep "${@:2}" >&2
}

error() {
    printf "%s: error: $1" barkeep "${@:2}" >&2
    exit 1
}

mkcover() {
    if [[ $2 =~ [https?|f]tp ]]; then
        if COLUMNS=40 curl --remove-on-error -#Lgfo "$1"/cover.download -- "$2"; then
            set -- "$1" "$1"/cover.download
        else
            warn '%s: failed to download cover\n' "$2"
        fi
    fi

    if [[ -f $2 ]]; then
        magick -define filename:literal=true "$2" -thumbnail 368x527\! "$2".tmp || exit

        mv -f -- "$2".tmp "$1"/cover
        rm -f -- "$1"/cover.download
    else
        error '%s: unable to find cover\n' "$2"
    fi
}

ls_cmd() {
    local opt dir=$bindir

    while getopts :th0 opt; do
        case $opt in
        t) dir=$templatedir ;;
        0) fmt='%s\0' ;;
        h) ls_usage; exit ;;
        *) ls_usage >&2; exit 1 ;;
        esac
    done

    set -- "$dir"/*

    if [[ $# -gt 0 ]]; then
        printf "${fmt:-'%s\n'}" "${@##*/}"
    fi
}

mk_cmd() {
    local opt entry cover template

    while getopts :c:t:e:n:h opt; do
        case $opt in
        c) cover=$OPTARG ;;
        t) template=$OPTARG ;;
        n) title=$OPTARG ;;
        h) mk_usage; exit ;;
        *) mk_usage >&2; exit 1
        esac
    done

    shift "$((OPTIND-1))"

    title=${title:-$1}

    case $1 in
    '') error 'entry name required\n' ;;
    */*) error '%s: <slash> (/) not allowed in entry name\n' "$1" ;;
    *) entry=$bindir/$1
    esac

    if [[ -e $entry ]]; then
        error '%s: entry exists\n' "$entry"
    fi

    if [[ $template && ! -f $template ]]; then
        error '%s: no such template\n' "$template"
    fi

    mkdir -p -- "$entry"

    printf '%s\n' "$title" > "$entry"/title

    if [[ $cover ]]; then
        mkcover "$entry" "$cover"
    fi

    if [[ $template ]]; then
        cp -f -- "$templatedir"/"$template" "$entry"/run
    else
        touch -- "$entry"/run
    fi

    $editor "$entry"/run
    chmod -c -- +x "$entry"/run
}

rm_cmd() {
    local opt entry

    while getopts :h opt; do
        case $opt in
        h) rm_usage; exit ;;
        *) rm_usage >&2; exit 1
        esac
    done

    shift "$((OPTIND-1))"

    if [[ $# -eq 0 ]]; then
        error 'no entry provided\n'
    fi

    for entry do
        if [[ -e "$bindir"/"$entry" ]]; then
            set -- "$@" "$bindir"/"$entry"
        else
            warn '%s: no such entry\n' "$entry"
        fi

        shift
    done

    # N.B. Avoid ARG_MAX via xargs using awk to prune duplicates.
    awk 'BEGIN {for(i=2;i<=ARGC;++i) if(!s[ARGV[i]]++) printf "%s\0", ARGV[i]}' -- "$@" \
    | xargs -r0 rm -rf --
}

ed_cmd() {
    local entry cover template

    while getopts :c:n:ht opt; do
        case $opt in
        t) template=1 ;;
        c) cover=$OPTARG ;;
        n) title=$OPTARG ;;
        h) ed_usage; exit ;;
        *) ed_usage >&2; exit 1
        esac
    done

    shift "$((OPTIND-1))"

    if [[ $template ]]; then
        entry=$templatedir/$1
    else
        entry=$bindir/$1
    fi

    if [[ ! -e "$entry" ]]; then
        error '%s: no such entry\n' "$1"
    fi

    if [[ $template ]]; then
        $editor "$entry"
    else
        if [[ $title ]]; then
            printf '%s\n' "$title" > "$entry"/title
        fi

        if [[ $cover ]]; then
            mkcover "$entry" "$cover"
        else
            $editor "$entry"
        fi
    fi
}

shopt -s nullglob

datadir=${XDG_DATA_HOME:-$HOME/.local/share}/taverner

bindir=$datadir/bin
templatedir=$datadir/templates

editor=${EDITOR:-vi}

while getopts :he: opt; do
    case $opt in
    e)
        editor=$OPTARG
    ;;
    h)
        usage
        printf 'commands\n\n'

        for cmd in mk ls ed rm; do
            "$cmd"_usage
        done | pr -to 4

        exit
    ;;
    *)
        usage >&2
        exit 1
    esac
done

shift "$((OPTIND-1))"

# N.B. Reset OPTIND for subsequent calls to getopts.
OPTIND=1

mkdir -p -- "$bindir" "$templatedir" || exit

case $1 in
ed|ls|mk|rm) cmd=$1; shift; "$cmd"_cmd "$@" ;;
*) usage; exit 1
esac
