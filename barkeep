#!/usr/bin/env bash
# barkeep
# Creates a game entry based on a template for use with `taverner`

# Includes get_abs_dir, in_array, chk_exists_dir, confirm, err, warn, debug, msg
if ! source "$HOME"/.local/lib/libtavern; then
    printf >&2 '[ERR] Failed to source %s\n' "$HOME"/.local/lib/libtavern
    exit 1
fi

# Options
shopt -s nullglob

# Globals
prefix="$HOME"/games
bindir="$prefix"/bin
cachedir="$prefix"/share/cache
coverdir="$prefix"/share/covers
templatedir="$prefix"/share/templates
placeholder="$prefix"/share/covers/placeholder.cover

TMPDIR=/tmp # Used for internet incoming images

# Check that the directories actually exist before attempting anything
dirs_exist "$prefix" "$bindir" "$coverdir" "$cachedir" "$templatedir" "$TMPDIR"


# Functions and helpers
usage() {
    cat <<EOF
Usage: barkeep -n <name> -t <template> [-c <cover>] [-e <editor>] [-l]
       barkeep -r [name [name [...]]]

    Operations:
        -l      List all available templates
        -n      Name of the new game launcher script
        -t      Select a template to base the new entry on
        -c      Path or url to a cover image (note: this is destructive)
        -e      Prefered editor, uses \$EDITOR if not set

    Single Operations:
        -r      Remove launcher(s), cover(s) and reset database
                If no argument given, attempt to remove all launchers

    Examples:
        # Creates an entry using the psx template called wipeout_3 using emacs
        # as the editor
        barkeep -e emacs -n wipeout_3 -t psx -c ~/wipeout.png
        
        # Removes both wipeout_3 and crash_bandicoot launchers along with any
        # cover images if found and resets the cache
        barkeep -r wipeout_3 crash_bandicoot

EOF
}

chk_template() {
    local name="$1"
    local t list
    
    for t in "$templatedir"/*; do
        list+=("${t##*/}")
    done

    # Generate a list for `barkeep -l`
    if [[ "$name" == list && -n "${t[@]}" ]]; then
        printf '%03s\n' "${list[@]}"
        exit 0
    # If we found no templates at all
    elif [[ -z "${list[@]}" ]]; then
        err "No templates available"
        exit 1
    # Then make sure the chosen template exists itself
    elif ! in_array "$name" "${list[@]}"; then
        err "$template: No such template"
        exit 1
    fi
}

resize_cover() {
    local image="$1"

    if [[ -e "$image" ]]; then
        command convert "$image" -resize 368x527\! "$image"
    fi
}

rm_launcher() {
    local names
    local n coverimg

    if [[ -n "$@" ]]; then
        names=("$@")
    else
        # If we get no arguments, just add everything we can find in the bindir
        names=("$bindir"/*)
    fi

    for n in "${names[@]}"; do
        coverimg="$coverdir"/"${n##*/}".cover

        # If the file doesn't actually exist, skip it instead of failing
        if [[ ! -e "$bindir"/"${n##*/}" ]]; then
            warn "$bindir/${n##*/}: No such file, skipping"
        elif confirm "Remove $bindir/${n##*/}?"; then
            rm -vf -- "$bindir"/"${n##*/}"
            rm -vf -- "$cachedir"/cache.db

            # Make sure a cover image exists before trying to remove it
            if [[ -e "$coverimg" ]]; then
                rm -vf -- "$coverdir"/"${n##*/}".cover
            fi
        fi
    done
}

mk_template() {
    local name="$1"
    local template="$2"

    # Check the template and make sure it doesn't already exist and is available
    chk_template "$template"

    if [[ -e "$bindir"/"$name" ]]; then
        err "$bindir/$name: Already exists"
        exit 1
    else
        cp -v -- "$templatedir"/"$template" "$bindir"/"$name"
        chmod -c +x -- "$bindir"/"$name"
    fi
}

mk_cover() {
    local name="$1"
    local cover="$2"
    local coverpath

    # Lets check that the placeholder actually exists here so warnings don't
    # appear when removing titles that have nothing to do with the placeholder
    if [[ ! -e "$placeholder" ]]; then
        warn "$placeholder: Not found, using nothing instead"
        placeholder="nothing"
    fi

    # Support http, https and ftp 
    if [[ "$cover" =~ [ht\|f]tps? ]]; then
        if curl -o "$TMPDIR"/barkeep-image "$cover"; then
            coverpath="$TMPDIR"/barkeep-image
        else
            warn "Failed to fetch $cover"
        fi
    else
        # Get the absolute path to the cover image 
        coverpath="$(get_abs_dir "$cover")"
    fi

    if [[ ! -e "$coverpath" ]]; then
        warn "No cover image available, using $placeholder"
    fi

    if [[ -e "$coverdir"/"$name" ]]; then
        warn "$coverdir/$name: Already exists, using $coverdir/$name.cover"
    elif [[ -e "$coverpath" ]]; then
        mv -v -- "$coverpath" "$coverdir"/"$name".cover
        if ! resize_cover "$coverdir"/"$name".cover; then
            warn "Failed to resize image, falling back to $placeholder"
            rm -vf -- "$coverdir"/"$name".cover
        fi
    fi
}

# We need at least one argument, if none are provided display usage information
# and exit
if (($# == 0)); then
    err "At least one argument is required"
    usage
    exit 1
fi

# I will handle the errors manually
while getopts ':hlt:d:c:n:re:' argv; do
    case "$argv" in
        n)
            name="$OPTARG"

            # The following is a hack to work around multiple arguments given to 
            # a single option, this will use current OPTIND as the index to $@
            # plus one argument, then if it doesn't begin with a '-', increment
            # it, skipping extra non-arguments until we fine one.
            
            # This allows us to restrict an option to only accept a single 
            # argument.
            [[ "${@:OPTIND:1}" != -* ]] && ((++OPTIND))
            ;;
        t)
            template="$OPTARG"
            [[ "${@:OPTIND:1}" != -* ]] && ((++OPTIND))
            ;;
        e)
            editor="$OPTARG"
            [[ "${@:OPTIND:1}" != -* ]] && ((++OPTIND))
            ;;
        c)
            cover="$OPTARG"
            [[ "${@:OPTIND:1}" != -* ]] && ((++OPTIND))
            ;;
        r)
            remove=t
            shift
            ;;
        l)
            chk_template list
            ;;
        h)
            usage
            exit 0
            ;;
        :)
            err "Option -$OPTARG requires an argument"
            usage
            exit 1
            ;;
        ?)
            err "Invalid option: -$OPTARG"
            usage
            exit 1
            ;;
    esac
done

# Process removal before continuing making sure that both of the mandatory
# arguments aren't set before attempting it
if [[ "$remove" == t && -z "$name" && -z "$template" ]]; then
    rm_launcher "$@"
    exit 0
fi

# Make sure a name is supplied
if [[ -z "$name" ]]; then
    err "A NAME is required"
    exit 1
fi

# Set the editor if none was specified
if [[ -z "$editor" ]]; then
    EDITOR="${VISUAL:-$EDITOR}"
else
    EDITOR="$editor"
fi

# Exit before making a template as an editor is required, otherwise we could
# just make a note of this and not run an editor after creation
if ! hash "$EDITOR" &> /dev/null; then
    err "$EDITOR: Does not exist"
    exit 1
fi

# Make sure a template was chosen
if [[ -n "$template" ]]; then
    mk_template "$name" "$template"
else
    err "No template selected"
    exit 1
fi

if [[ -n "$cover" ]]; then
    mk_cover "$name" "$cover"
else
    warn "No image selected, using $placeholder"
fi

# Let the user edit the template, I'm not going to try run a CPP over this or any
# other kind of templating engine as it just increases complexity, maybe...
command "$EDITOR" "$bindir"/"$name"
