#!/usr/bin/env bash
# libtavern
# Common functions used in the taverner project

# Prefer terminal safe coloured and bold text when tput is supported
if hash tput &>/dev/null; then
    sgr0="$(tput sgr0)"
    bold="$(tput bold)"
    red="$bold$(tput setaf 1)"
	blue="$bold$(tput setaf 4)"
    yellow="$bold$(tput setaf 3)"
else
    sgr0="\e[1;0m"
    bold="\e[1;1m"
    red="$bold\e[1;31m"
    blue="$bold\e[1;34m"
    yellow="$bold\e[1;33m"
fi

readonly sgr0 bold red yellow blue

debug() {
    printf >&2 '%s[DBG]%s %s\n' "$blue" "$sgr0" "$@"
}

err() {
    printf >&2 '%s[ERR]%s %s\n' "$red" "$sgr0" "$@"
}

warn() {
    printf >&2 '%s[WRN]%s %s\n' "$yellow" "$sgr0" "$@"
}

msg() {
    printf >&2 '      %s\n' "$@"
}

in_array() {
    local i

    for i in "${@:2}"; do
        if [[ $1 == "$i" ]]; then
            return 0
        fi
    done
    # No match
    return 1
}

# Takes an argument and returns an absolute path
get_abs_dir() {
    local dir="$1"

    # If the argument doesn't start with `/`, prepend $PWD
    if [[ "${dir:0:1}" != / ]]; then
        printf '%s/%s\n' "$PWD" "$dir"
    else
        printf '%s\n' "$dir"
    fi
}

confirm() {
    local msg="$1"
    local -l reply

    read -p "$msg [Y/n] " reply

    # If the reply is empty, assume Y
    if [[ -z "$reply" || "$reply" = y?(es) ]]; then
        return 0
    else
        return 1
    fi
}

dirs_exist() {
    local dirs=("$@")
    local d

    for d in "${dirs[@]}"; do
        if [[ ! -d "$d" ]]; then
            err "$d does not exist"
            exit 1
        fi
    done
}
